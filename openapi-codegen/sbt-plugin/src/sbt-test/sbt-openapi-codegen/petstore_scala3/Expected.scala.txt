package sttp.tapir.generated

object TapirGeneratedEndpoints {

  import sttp.tapir._
  import sttp.tapir.model._
  import sttp.tapir.generic.auto._
  import sttp.tapir.json.circe._
  import io.circe.generic.semiauto._
  
  import sttp.tapir.generated.TapirGeneratedEndpointsJsonSerdes._
  import TapirGeneratedEndpointsSchemas._

  def enumMap[E: enumextensions.EnumMirror]: Map[String, E] =
    Map.from(
      for e <- enumextensions.EnumMirror[E].values yield e.name.toUpperCase -> e
    )
  def makeQueryCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain] =
    sttp.tapir.Codec
      .listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(s =>
        // Case-insensitive mapping
        scala.util
          .Try(enumMap[T](using enumextensions.EnumMirror[T])(s.toUpperCase))
          .fold(
            _ =>
              sttp.tapir.DecodeResult.Error(
                s,
                new NoSuchElementException(
                  s"Could not find value $s for enum ${enumextensions.EnumMirror[T].mirroredName}, available values: ${enumextensions.EnumMirror[T].values.mkString(", ")}"
                )
              ),
            sttp.tapir.DecodeResult.Value(_)
          )
      )(_.name)
  def makeExplodedQueryCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], List[T], sttp.tapir.CodecFormat.TextPlain] = {
    val eMap = enumMap[T](using enumextensions.EnumMirror[T])
    sttp.tapir.Codec
      .list[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(values =>
        // Case-insensitive mapping
        scala.util
          .Try(values.map(s => eMap(s.toUpperCase)))
          .fold(
            _ =>
              sttp.tapir.DecodeResult.Error(
                values.mkString(","),
                new NoSuchElementException(
                  s"Could not find all values $values for enum ${enumextensions.EnumMirror[
                    T].mirroredName}, available values: ${enumextensions.EnumMirror[T].values.mkString(", ")}")),
            sttp.tapir.DecodeResult.Value(_)))(_.map(_.name))
  }
  sealed trait ADTWithoutDiscriminator
  sealed trait ADTWithDiscriminator
  sealed trait ADTWithDiscriminatorNoMapping
  case class Pet (
    status: Option[PetStatus] = None,
    tags: Option[Seq[Tag]] = None,
    id: Option[Long] = None,
    photoUrls: Seq[String],
    name: String,
    category: Option[Category] = None
  )
  
  enum PetStatus derives org.latestbit.circe.adt.codec.JsonTaggedAdt.PureCodec {
    case available, pending, sold
  }
  case class Category (
    id: Option[Long] = None,
    name: Option[String] = None
  )
  case class Address (
    street: Option[String] = None,
    city: Option[String] = None,
    state: Option[String] = None,
    zip: Option[String] = None
  )
  case class SubtypeWithoutD1 (
    s: String,
    i: Option[Int] = None,
    a: Seq[String]
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD1 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping
  case class SubtypeWithoutD3 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithoutD2 (
    a: Seq[String]
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD2 (
    s: String,
    a: Option[Seq[String]] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping
  case class Tag (
    id: Option[Long] = None,
    name: Option[String] = None
  )
  case class Customer (
    id: Option[Long] = None,
    username: Option[String] = None,
    address: Option[Seq[Address]] = None
  )
  case class User (
    userStatus: Option[Int] = None,
    phone: Option[String] = None,
    lastName: Option[String] = None,
    id: Option[Long] = None,
    username: Option[String] = None,
    password: Option[String] = None,
    email: Option[String] = None,
    firstName: Option[String] = None
  )
  case class Order (
    id: Option[Long] = None,
    status: Option[OrderStatus] = None,
    shipDate: Option[java.time.Instant] = None,
    quantity: Option[Int] = None,
    complete: Option[Boolean] = None,
    petId: Option[Long] = None
  )
  
  enum OrderStatus derives org.latestbit.circe.adt.codec.JsonTaggedAdt.PureCodec {
    case placed, approved, delivered
  }
  case class ApiResponse (
    code: Option[Int] = None,
    `type`: Option[String] = None,
    message: Option[String] = None
  )

  type SwaggerRouterControllerExtension = String
  val swaggerRouterControllerExtensionKey = new sttp.tapir.AttributeKey[SwaggerRouterControllerExtension]("sttp.tapir.generated.TapirGeneratedEndpoints.SwaggerRouterControllerExtension")

  lazy val placeOrder =
    endpoint
      .post
      .in(("store" / "order"))
      .in(jsonBody[Option[Order]])
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .out(jsonBody[Order].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")
  
  lazy val findPetsByTags =
    endpoint
      .get
      .in(("pet" / "findByTags"))
      .in(query[List[String]]("tags").description("Tags to filter by"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid tag value"))
      .out(jsonBody[List[Pet]].description("successful operation"))
      .tags(List("pet"))
  
  lazy val updatePet =
    endpoint
      .put
      .in(("pet"))
      .in(jsonBody[Pet])
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Pet not found"))
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Validation exception"))
      .out(jsonBody[Pet].description("Successful operation"))
      .tags(List("pet"))
  
  lazy val addPet =
    endpoint
      .post
      .in(("pet"))
      .in(jsonBody[Pet])
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .out(jsonBody[Pet].description("Successful operation"))
      .tags(List("pet"))
  
  lazy val getOrderById =
    endpoint
      .get
      .in(("store" / "order" / path[Long]("orderId").description("ID of order that needs to be fetched")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Order not found"))
      .out(jsonBody[Order].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")
  
  lazy val deleteOrder =
    endpoint
      .delete
      .in(("store" / "order" / path[Long]("orderId").description("ID of the order that needs to be deleted")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Order not found"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")
  
  lazy val logoutUser =
    endpoint
      .get
      .in(("user" / "logout"))
      .tags(List("user"))
  
  lazy val getInventory =
    endpoint
      .get
      .in(("store" / "inventory"))
      .securityIn(auth.apiKey(header[String]("api_key")))
      .out(jsonBody[Map[String, Int]].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")
  
  lazy val createUsersWithListInput =
    endpoint
      .post
      .in(("user" / "createWithList"))
      .in(jsonBody[Option[List[User]]])
      .out(jsonBody[User].description("Successful operation"))
      .tags(List("user"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "UserController")
  
  lazy val putAdtTest =
    endpoint
      .put
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithoutDiscriminator])
      .out(jsonBody[ADTWithoutDiscriminator].description("successful operation"))
  
  lazy val postAdtTest =
    endpoint
      .post
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithDiscriminatorNoMapping])
      .out(jsonBody[ADTWithDiscriminator].description("successful operation"))
  
  lazy val getUserByName =
    endpoint
      .get
      .in(("user" / path[String]("username").description("The name that needs to be fetched. Use user1 for testing. ")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("User not found"))
      .out(jsonBody[User].description("successful operation"))
      .tags(List("user"))
  
  lazy val updateUser =
    endpoint
      .put
      .in(("user" / path[String]("username").description("name that needs to be updated")))
      .in(jsonBody[Option[User]])
      .tags(List("user"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "UserController")
  
  lazy val deleteUser =
    endpoint
      .delete
      .in(("user" / path[String]("username").description("The name that needs to be deleted")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("User not found"))
      .tags(List("user"))
  
  lazy val loginUser =
    endpoint
      .get
      .in(("user" / "login"))
      .in(query[String]("username").description("The user name for login"))
      .in(query[String]("password").description("The password for login in clear text"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username/password supplied"))
      .out(jsonBody[String].description("successful operation"))
      .tags(List("user"))
  
  lazy val createUser =
    endpoint
      .post
      .in(("user"))
      .in(jsonBody[Option[User]])
      .errorOut(jsonBody[User].description("successful operation"))
      .tags(List("user"))
  
  lazy val getPetById =
    endpoint
      .get
      .in(("pet" / path[Long]("petId").description("ID of pet to return")))
      .securityIn(auth.apiKey(header[String]("api_key")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Pet not found"))
      .out(jsonBody[Pet].description("successful operation"))
      .tags(List("pet"))
  
  lazy val updatePetWithForm =
    endpoint
      .post
      .in(("pet" / path[Long]("petId").description("ID of pet that needs to be updated")))
      .in(query[String]("name").description("Name of pet that needs to be updated"))
      .in(query[String]("status").description("Status of pet that needs to be updated"))
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .tags(List("pet"))
  
  lazy val deletePet =
    endpoint
      .delete
      .in(("pet" / path[Long]("petId").description("Pet id to delete")))
      .in(header[String]("api_key").description(""))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid pet value"))
      .tags(List("pet"))
  
  lazy val uploadFile =
    endpoint
      .post
      .in(("pet" / path[Long]("petId").description("ID of pet to update") / "uploadImage"))
      .in(query[String]("additionalMetadata").description("Additional Metadata"))
      .in(multipartBody)
      .out(jsonBody[ApiResponse].description("successful operation"))
      .tags(List("pet"))
  
  lazy val findPetsByStatus =
    endpoint
      .get
      .in(("pet" / "findByStatus"))
      .in(query[List[FindPetsByStatusStatus]]("status").description("Status values that need to be considered for filter"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid status value"))
      .out(jsonBody[List[Pet]].description("successful operation"))
      .tags(List("pet"))
  
  object FindPetsByStatusStatus {
    given stringListFindPetsByStatusStatusCodec: sttp.tapir.Codec[List[String], List[FindPetsByStatusStatus], sttp.tapir.CodecFormat.TextPlain] =
      makeExplodedQueryCodecForEnum[FindPetsByStatusStatus]
  }
  enum FindPetsByStatusStatus derives enumextensions.EnumMirror {
    case available, pending, sold
  }
  
  
  lazy val generatedEndpoints: List[sttp.tapir.AnyEndpoint] = List(placeOrder, findPetsByTags, updatePet, addPet, getOrderById, deleteOrder, logoutUser, getInventory, createUsersWithListInput, putAdtTest, postAdtTest, getUserByName, updateUser, deleteUser, loginUser, createUser, getPetById, updatePetWithForm, deletePet, uploadFile, findPetsByStatus)

}
