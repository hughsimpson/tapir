package sttp.tapir.generated

object TapirGeneratedEndpoints {

  import sttp.tapir._
  import sttp.tapir.model._
  import sttp.tapir.generic.auto._
  import sttp.tapir.json.circe._
  import io.circe.generic.semiauto._

  import sttp.tapir.generated.TapirGeneratedEndpointsJsonSerdes._
  import TapirGeneratedEndpointsSchemas._

  def makeQueryCodecForEnum[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]): sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain] =
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(s =>
        // Case-insensitive mapping
        scala.util.Try(T.upperCaseNameValuesToMap(s.toUpperCase))
          .fold(
            _ =>
              sttp.tapir.DecodeResult.Error(
                s,
                new NoSuchElementException(
                  s"Could not find value $s for enum ${enumName}, available values: ${T.values.mkString(", ")}"
                )
              ),
            sttp.tapir.DecodeResult.Value(_)
          )
      )(_.entryName)
  def makeExplodedQueryCodecForEnum[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]): sttp.tapir.Codec[List[String], List[T], sttp.tapir.CodecFormat.TextPlain] =
      sttp.tapir.Codec.list[String, String, sttp.tapir.CodecFormat.TextPlain]
        .mapDecode(values =>
          // Case-insensitive mapping
          scala.util.Try(values.map(s => T.upperCaseNameValuesToMap(s.toUpperCase)))
            .fold(
              _ =>
                sttp.tapir.DecodeResult.Error(
                  values.mkString(","),
                  new NoSuchElementException(
                    s"Could not find all values $values for enum ${enumName}, available values: ${T.values.mkString(", ")}"
                  )
                ),
              sttp.tapir.DecodeResult.Value(_)
            )
        )(_.map(_.entryName))
  sealed trait ADTWithoutDiscriminator
  sealed trait ADTWithDiscriminator
  sealed trait ADTWithDiscriminatorNoMapping
  case class Pet (
    status: Option[PetStatus] = None,
    tags: Option[Seq[Tag]] = None,
    id: Option[Long] = None,
    photoUrls: Seq[String],
    name: String,
    category: Option[Category] = None
  )

  sealed trait PetStatus extends enumeratum.EnumEntry
  object PetStatus extends enumeratum.Enum[PetStatus] with enumeratum.CirceEnum[PetStatus] {
    val values = findValues
    case object available extends PetStatus
    case object pending extends PetStatus
    case object sold extends PetStatus
  }
  case class Category (
    id: Option[Long] = None,
    name: Option[String] = None
  )
  case class Address (
    street: Option[String] = None,
    city: Option[String] = None,
    state: Option[String] = None,
    zip: Option[String] = None
  )
  case class SubtypeWithoutD1 (
    s: String,
    i: Option[Int] = None,
    a: Seq[String]
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD1 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping
  case class SubtypeWithoutD3 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithoutD2 (
    a: Seq[String]
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD2 (
    s: String,
    a: Option[Seq[String]] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping
  case class Tag (
    id: Option[Long] = None,
    name: Option[String] = None
  )
  case class Customer (
    id: Option[Long] = None,
    username: Option[String] = None,
    address: Option[Seq[Address]] = None
  )
  case class User (
    userStatus: Option[Int] = None,
    phone: Option[String] = None,
    lastName: Option[String] = None,
    id: Option[Long] = None,
    username: Option[String] = None,
    password: Option[String] = None,
    email: Option[String] = None,
    firstName: Option[String] = None
  )
  case class Order (
    id: Option[Long] = None,
    status: Option[OrderStatus] = None,
    shipDate: Option[java.time.Instant] = None,
    quantity: Option[Int] = None,
    complete: Option[Boolean] = None,
    petId: Option[Long] = None
  )

  sealed trait OrderStatus extends enumeratum.EnumEntry
  object OrderStatus extends enumeratum.Enum[OrderStatus] with enumeratum.CirceEnum[OrderStatus] {
    val values = findValues
    case object placed extends OrderStatus
    case object approved extends OrderStatus
    case object delivered extends OrderStatus
  }
  case class ApiResponse (
    code: Option[Int] = None,
    `type`: Option[String] = None,
    message: Option[String] = None
  )

  type SwaggerRouterControllerExtension = String
  val swaggerRouterControllerExtensionKey = new sttp.tapir.AttributeKey[SwaggerRouterControllerExtension]("sttp.tapir.generated.TapirGeneratedEndpoints.SwaggerRouterControllerExtension")

  lazy val placeOrder =
    endpoint
      .post
      .in(("store" / "order"))
      .in(jsonBody[Option[Order]])
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .out(jsonBody[Order].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")

  lazy val findPetsByTags =
    endpoint
      .get
      .in(("pet" / "findByTags"))
      .in(query[List[String]]("tags").description("Tags to filter by"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid tag value"))
      .out(jsonBody[List[Pet]].description("successful operation"))
      .tags(List("pet"))

  lazy val updatePet =
    endpoint
      .put
      .in(("pet"))
      .in(jsonBody[Pet])
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Pet not found"))
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Validation exception"))
      .out(jsonBody[Pet].description("Successful operation"))
      .tags(List("pet"))

  lazy val addPet =
    endpoint
      .post
      .in(("pet"))
      .in(jsonBody[Pet])
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .out(jsonBody[Pet].description("Successful operation"))
      .tags(List("pet"))

  lazy val getOrderById =
    endpoint
      .get
      .in(("store" / "order" / path[Long]("orderId").description("ID of order that needs to be fetched")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Order not found"))
      .out(jsonBody[Order].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")

  lazy val deleteOrder =
    endpoint
      .delete
      .in(("store" / "order" / path[Long]("orderId").description("ID of the order that needs to be deleted")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Order not found"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")

  lazy val logoutUser =
    endpoint
      .get
      .in(("user" / "logout"))
      .tags(List("user"))

  lazy val getInventory =
    endpoint
      .get
      .in(("store" / "inventory"))
      .securityIn(auth.apiKey(header[String]("api_key")))
      .out(jsonBody[Map[String, Int]].description("successful operation"))
      .tags(List("store"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "OrderController")

  lazy val createUsersWithListInput =
    endpoint
      .post
      .in(("user" / "createWithList"))
      .in(jsonBody[Option[List[User]]])
      .out(jsonBody[User].description("Successful operation"))
      .tags(List("user"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "UserController")

  lazy val putAdtTest =
    endpoint
      .put
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithoutDiscriminator])
      .out(jsonBody[ADTWithoutDiscriminator].description("successful operation"))

  lazy val postAdtTest =
    endpoint
      .post
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithDiscriminatorNoMapping])
      .out(jsonBody[ADTWithDiscriminator].description("successful operation"))

  lazy val getUserByName =
    endpoint
      .get
      .in(("user" / path[String]("username").description("The name that needs to be fetched. Use user1 for testing. ")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("User not found"))
      .out(jsonBody[User].description("successful operation"))
      .tags(List("user"))

  lazy val updateUser =
    endpoint
      .put
      .in(("user" / path[String]("username").description("name that needs to be updated")))
      .in(jsonBody[Option[User]])
      .tags(List("user"))
      .attribute[SwaggerRouterControllerExtension](swaggerRouterControllerExtensionKey, "UserController")

  lazy val deleteUser =
    endpoint
      .delete
      .in(("user" / path[String]("username").description("The name that needs to be deleted")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("User not found"))
      .tags(List("user"))

  lazy val loginUser =
    endpoint
      .get
      .in(("user" / "login"))
      .in(query[String]("username").description("The user name for login"))
      .in(query[String]("password").description("The password for login in clear text"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid username/password supplied"))
      .out(jsonBody[String].description("successful operation"))
      .tags(List("user"))

  lazy val createUser =
    endpoint
      .post
      .in(("user"))
      .in(jsonBody[Option[User]])
      .errorOut(jsonBody[User].description("successful operation"))
      .tags(List("user"))

  lazy val getPetById =
    endpoint
      .get
      .in(("pet" / path[Long]("petId").description("ID of pet to return")))
      .securityIn(auth.apiKey(header[String]("api_key")))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid ID supplied"))
      .errorOut(statusCode(sttp.model.StatusCode(404)).description("Pet not found"))
      .out(jsonBody[Pet].description("successful operation"))
      .tags(List("pet"))

  lazy val updatePetWithForm =
    endpoint
      .post
      .in(("pet" / path[Long]("petId").description("ID of pet that needs to be updated")))
      .in(query[String]("name").description("Name of pet that needs to be updated"))
      .in(query[String]("status").description("Status of pet that needs to be updated"))
      .errorOut(statusCode(sttp.model.StatusCode(405)).description("Invalid input"))
      .tags(List("pet"))

  lazy val deletePet =
    endpoint
      .delete
      .in(("pet" / path[Long]("petId").description("Pet id to delete")))
      .in(header[String]("api_key").description(""))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid pet value"))
      .tags(List("pet"))

  lazy val uploadFile =
    endpoint
      .post
      .in(("pet" / path[Long]("petId").description("ID of pet to update") / "uploadImage"))
      .in(query[String]("additionalMetadata").description("Additional Metadata"))
      .in(multipartBody)
      .out(jsonBody[ApiResponse].description("successful operation"))
      .tags(List("pet"))

  lazy val findPetsByStatus =
    endpoint
      .get
      .in(("pet" / "findByStatus"))
      .in(query[List[FindPetsByStatusStatus]]("status").description("Status values that need to be considered for filter"))
      .errorOut(statusCode(sttp.model.StatusCode(400)).description("Invalid status value"))
      .out(jsonBody[List[Pet]].description("successful operation"))
      .tags(List("pet"))

  sealed trait FindPetsByStatusStatus extends enumeratum.EnumEntry
  object FindPetsByStatusStatus extends enumeratum.Enum[FindPetsByStatusStatus] with enumeratum.CirceEnum[FindPetsByStatusStatus] {
    val values = findValues
    case object available extends FindPetsByStatusStatus
    case object pending extends FindPetsByStatusStatus
    case object sold extends FindPetsByStatusStatus
    implicit val findPetsByStatusStatusQueryCodec: sttp.tapir.Codec[List[String], List[FindPetsByStatusStatus], sttp.tapir.CodecFormat.TextPlain] =
      makeExplodedQueryCodecForEnum("FindPetsByStatusStatus", FindPetsByStatusStatus)
  }


  lazy val generatedEndpoints: List[sttp.tapir.AnyEndpoint] = List(placeOrder, findPetsByTags, updatePet, addPet, getOrderById, deleteOrder, logoutUser, getInventory, createUsersWithListInput, putAdtTest, postAdtTest, getUserByName, updateUser, deleteUser, loginUser, createUser, getPetById, updatePetWithForm, deletePet, uploadFile, findPetsByStatus)

}
